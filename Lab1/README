文件结构：
	/Lab
	    /Code
		Makefile
		lexical.l
		syntax.y
		main.c
		  .
		  .
	    /Test
		test1.cmm
		test2.cmm
		  .
		  .
	    /report.pdf
	    /parser
	    /README

Code目录：	1. 用于存放所有flex，bison，C语言源文件和头文件以及Makefile；
		2. 该目录下有一个Makefile文件，请使用它。除了定义和修改一些伪目标外不可对文件做其它修改（否则助教测试失败必扣分）；
		3. 请勿在该目录下创建子目录（如include、src等），实验的代码量还没有复杂到需要将头文件以及源文件分开管理的程度；
		4. 避免不合理的文件include关系，比如一个C文件include另一个C文件，Makefile执行时会报错。
	
Test目录：	1. 用于存放测试文件以及输出文件（如果有输出文件的话）；
		2. 请将测试文件以".cmm"作为后缀名。

report.pdf：	1. 该文件为你所需提交的实验报告，请自行完成后替换该文件。请在实验报告里写明姓名，学号和联系邮箱。
		（如果是组队提交的，只需一份实验报告）

parser：	1. 用你编译生成的二进制文件替换该文件。

README：	1. 你正打开着的...


这包括词法单元流的生成（2.1.1 节至2.1.5 节）、语法分析树的生成（2.1.6节至2.1.9 节），以及基本的错误处理等


1. flex运行过程 词法分析： #include "syntax.tab.h"
flex lexical.l
gcc main.c lex.yy.c -lfl -o scanner
./scanner test.cmm

2. 变量yytext的类型为char*，它是Flex为我们提供的一个变量，里面保存了当前词法单元所对应的词素。函数atoi()的作用是把一个字符串表示的整数转化为int类型。

3. P41 正则表达式怎么写

4. %option yylineno 读取yylineno 知道词法分析程序读到了哪一行

5. Flex 库函数input()可以从当前的输入文件中读入一个字符
   Flex 库函数unput(char c)可以将指定的字符放回输入缓冲区中
   Flex 库函数yyless(intn)可以将刚从输入缓冲区中读取的yyleng−n 个字符放回到输入缓冲区
   中，而函数yymore()可以告诉Flex 保留当前词素，并在下一个词法单元被识别出来之后将下一个
   词素连接到当前词素的后面。
   Flex 宏REJECT 可以帮助我们识别那些互相重叠的模式。当我们执行REJECT 之后，Flex 会
   进行一系列的操作，这些操作的结果相当于将yytext 放回输入之内，然后去试图匹配当前规则之
   后的那些规则

6. Bison运行过程 语法分析：P49
bison syntax.y (在在Bison源代码中引用lex.yy.c #include "lex.yy.c")
bison -d syntax.y
flex lexical.l
gcc main.c syntax.tab.c -lfl -ly -o parser
./parser test.cmm


7. 以%token开头的词法单元（终结符号）定义，如果需要采用Flex生成的yylex()
   的话，那么在这里定义的词法单元都可以作为Flex源代码里的返回值
   第二部分是书写产生式的地方。第一个产生式左边的非终结符号默认为初始符号（也可以通
   过在定义部分添加%start X来将另外的某个非终结符号X指定为初始符号）
   产生式里的箭头在这里用冒号“:”表示，一组产生式与另一组之间以分号“;”隔开。产生式里无论是终结符号还是
   非终结符号都各自对应一个属性值，产生式左边的非终结符号对应的属性值用$$表示，右边的几
   个符号的属性值按从左到右的顺序依次对应为$1、$2、$3等


8. 2.2.10 Bison：属性值的类型 P53

9. 除了属性值之外，每个语法单元还对应了一个位置信息，在语义
   动作中这些位置信息同样可以使用@$、@1、@2等进行引用。位置信息的数据类型是YYLTYPE

10. Bison也规定任何排在后面的运算符其优先级都要高于排在前面的运算符。